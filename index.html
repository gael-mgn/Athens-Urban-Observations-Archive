<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Athens Urban Observations Archive — AUOA</title>
  <meta name="description" content="Athens Urban Observations Archive (AUOA) is a digital archive dedicated to documenting and studying the city of Athens in all its dimensions: historical, social, cultural, and architectural." />
  <meta name="keywords" content="Athens, Urban Observations, Urbanism, Archive, digital archive">
  <meta property="og:image" content="athens-urban-observations-archive.webp" />
  <style>
:root{
  --bg:#fdfdfd;
  --ink:#000;
  --ink-mute:#777;
  --panel:#f4f4f4;
  --line:2px solid #000;
  --gap:32px;
  --radius:0;
  --font-sans:"Inter", "Helvetica Neue", Arial, sans-serif;
  --font-serif:"Inter", "Helvetica Neue", Arial, sans-serif;
}
a { color: var(--ink); }
html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:var(--font-sans);font-size:16px;line-height:1.4;}
body{padding:40px;}
*{box-sizing:border-box;letter-spacing:-0.01em;}
.wrap{ max-width:1240px; margin:0 auto; display:grid; grid-template-columns:1fr 380px; gap:var(--gap); }
header{ grid-column:1/-1; border-bottom:var(--line); padding-bottom:16px; display:flex; justify-content:space-between; align-items:flex-end; }
.site-title{ font-family:var(--font-serif); font-size:26px; font-weight:700; margin-bottom:4px; }
header small{font-size:12px;color:var(--ink-mute)}
nav{display:flex;gap:18px;}
nav a{ text-decoration:none; color:var(--ink); font-weight:600; padding:6px 0; border-bottom:2px solid transparent; }
nav a:hover{ border-bottom:2px solid var(--ink); }
.hero{ padding:38px 32px; background:var(--panel); border:var(--line); display:flex;flex-direction:column; gap:18px; }
.hero h1{ margin:0; font-family:var(--font-serif); font-size:40px; line-height:1.1; }
.hero p{margin:0;color:var(--ink-mute);max-width:70%;font-size:15px;}
.hero .cta{ padding:12px 18px; border:var(--line); background:#fff; font-weight:800; text-transform:uppercase; }
.hero .cta:hover{ background:var(--ink); color:#fff; }
.archive{ border:var(--line); padding:20px; background:#fff; }
.controls{ display:flex; flex-wrap:wrap; gap:12px; margin-bottom:20px; }
.controls input[type=search]{ flex:1; padding:12px; border:var(--line); font-family:var(--font-sans); }
input[type="checkbox"] { accent-color: black; }
.controls button{ padding:12px 14px; border:var(--line); background:#fff; font-weight:700; text-transform:uppercase; cursor:pointer; }
.controls button:hover{ background:var(--ink); color:#fff; }
.list{display:flex;flex-direction:column;gap:22px;}
.item{ border:var(--line); background:#fafafa; padding:0; }
.item summary { cursor: pointer; list-style: none; padding: 16px 18px; border-bottom: var(--line); display: flex; justify-content: space-between; font-weight: 800; font-size: 15px; gap: 20px; transition: background-color 0.4s ease, color 0.4s ease; }
.item summary:hover { background: black; color: white; }
.item summary::-webkit-details-marker{display:none;}
.details-body{ padding:20px; }
.thumb{ width:100%; object-fit:cover; border:var(--line); }

/*.thumb {
  width: 100%;
  max-height: 500px;
  object-fit: contain;
  border: var(--line);
}*/

figure { margin: 0; padding: 0; margin-bottom: 10px; }
figcaption { font-size: 13px; color: var(--ink-mute); }
.info{ display:grid; grid-template-columns:1fr 150px; gap:18px; }
.info a {
  word-break: break-all; /* Permet de couper le texte en plein mot si nécessaire */
    overflow-wrap: break-word; /* Gère les retours à la ligne si le texte est trop long */
    max-width: 100%; 
}
.meta-tags{ margin-top:10px; }
.tag{ padding:4px 8px; border:var(--line); background:#fff; font-size:11px; font-weight:700; cursor:pointer; }
.tag:hover{ background:var(--ink); color:#fff; }
#quickFilters button { cursor:pointer; }
#quickFilters button.active, #formatFilters button.active { background: black; color: white; border-color: black; }
.meta-small{font-size:13px;color:var(--ink-mute);}
.coment { margin-top:10px; font-size:14px; color:var(--ink); white-space: pre-wrap; }
aside { position: sticky; top: 20px; max-height: calc(150vh); }
.meta{ border:var(--line); padding:18px; background:#fff; }
.meta select { width: 100%; padding: 6px 8px; margin-bottom: 8px; border: var(--line); background: #fff; font-size: 13px; }
.meta h3{ margin-top:0; font-size:14px; letter-spacing:0; }
.meta button{ padding:6px 10px; border:var(--line); background:#fff; font-size:12px; font-weight:700; }
.meta button:hover{ background:var(--ink); color:#fff; }
.tag-line {margin: 0; padding: 0; display: block; }
.sep { text-decoration: none; }
.tag-link { text-decoration: underline; }

footer{ grid-column:1/-1; border-top:var(--line); padding-top:16px; margin-top:32px; display:flex; justify-content:space-between; font-size:14px; }
@media(max-width:980px){
  .no-mobile { display: none; }
  body{padding:20px;}
  .wrap{grid-template-columns:1fr;}
  aside{order:3;margin-top:0px;}
  aside { position: relative; }
  .archive{order:2;}
  .hero{order:1;}
  .info{grid-template-columns:1fr;}
  .hero p{max-width:100%;}
}
@media(max-width:980px){
  .controls input[type=search]{ width: 100%; }
}

/* container mobile: invisible sur desktop, visible sur mobile */
.mobile-filters { display: none; margin: 18px 0; gap: 12px; }
@media (max-width:980px) {
  .mobile-filters { display: block; }
  /* spacing / box look similaire aux .meta */
  .mobile-filters .meta { border: var(--line); padding: 12px; background: #fff; margin-bottom: 12px; }
  /* rendre select/buttons plus larges si besoin */
}

/* Desktop only: make list a fixed-scroll area */
@media (min-width: 981px) {
  /* wrapper: ensure archive doesn't overflow */
  .archive {
    overflow: visible; /* permet au .list de scroller indépendamment */
  }

  /* zone scrollable pour la liste d'articles */
  #list {
    overflow: auto;           /* affichage du scroll quand nécessaire */
    -webkit-overflow-scrolling: touch;
    /* valeur par défaut au cas où JS est désactivé : ajuste le 500px selon préférence */
    max-height: 85vh;
    padding-right: 8px;       /* évite que le contenu touche le bord quand scrollbar visible */
  }
}

  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div>
          <div class="site-title" style="font-weight: bold;">Athens Urban Observations Archive</div>
          <div style="font-size:12px;color:var(--muted)">An Online Ethnographic and Urban Repository on Athenian Spaces in Transition</div>
        </div>
      </div>
      <nav aria-label="Navigation principale" class="no-mobile">
        <a href="">Project</a>
        <a href="#about">About</a>
        <a href="#contact">Contact</a>
      </nav>
    </header>

    <main>
      <section class="hero" aria-labelledby="hero-title">
        <h1 id="hero-title">Athens Urban Observations Archive :<br>
An Online Ethnographic and Urban Repository on Athenian Spaces in Transition</h1>
        <p>The project aims to create a collaborative online archive documenting subtle, overlooked, or transitional spaces of Athens. It blends urban studies, ethnography, visual culture, and citizen contributions to build a living memory of the city’s informal, contested, or reappropriated places.</p>
      </section>

      <!-- insérer directement après </section> de .hero -->
      <div id="mobileFilters" class="mobile-filters" aria-hidden="true"></div>


      <section id="archives" class="archive" aria-labelledby="archives-title">
        <div class="controls">
          <input id="searchbox" type="search" placeholder="Search" oninput="filterList()" />
          <button onclick="resetFilters()">Reset filters</button>
          <button onclick="sortBy('date')" class="no-mobile">Sort by date</button>
        </div>

        <div id="list" class="list" role="list"></div>
      </section>
    </main>

    <aside>
      <div class="meta">
        <h3>Quick filters</h3>
        <p style="margin-bottom: 0;">Click on a tag in the list below to filter the results. (<a href="thesaurus.html">index de classification</a>)</p>
        <div id="quickFilters" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"></div>
      </div>

      <div style="height:16px"></div>

      <div class="meta">
        <h3>Localisation</h3>
        <select id="positionFilter" onchange="filterLocation()"></select>
        <select id="municipaliteFilter" onchange="filterLocation()"></select>
        <select id="quartierFilter" onchange="filterLocation()"></select>
      </div>

      <div style="height:16px"></div>

      <div class="meta">
        <h3>Format</h3>
        <div id="formatFilters" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"></div>
      </div>

      <div style="height:16px"></div>
    </aside>

    <footer>
      <div>© <strong>Athens Urban Observations Archive</strong> — <span id="year"></span></div>
      <script>document.getElementById("year").textContent = new Date().getFullYear();</script>
    </footer>
  </div>


<script src="data/codemap.js"></script>

<script>
  /* --- Responsive : déplacer les .meta de aside vers #mobileFilters sur mobile --- */
(function(){
  const MOBILE_QUERY = '(max-width:980px)';
  const mql = window.matchMedia(MOBILE_QUERY);
  const aside = document.querySelector('aside');
  const mobileContainer = document.getElementById('mobileFilters');

  if (!aside || !mobileContainer) return;

  // capture order initiale (NodeList -> Array)
  const metas = Array.from(aside.querySelectorAll('.meta'));

  // helper : move elements into container (preserve nodes)
  function moveToMobile() {
    if (!metas || metas.length === 0) return;
    // set aria
    mobileContainer.setAttribute('aria-hidden','false');
    metas.forEach(el => {
      // avoid moving if already moved
      if (el.parentElement !== mobileContainer) mobileContainer.appendChild(el);
    });
  }

  // helper : move elements back to aside (restaure ordre initial)
  function moveToAside() {
    if (!metas || metas.length === 0) return;
    mobileContainer.setAttribute('aria-hidden','true');
    metas.forEach(el => {
      // append back to aside (restaure ordre)
      if (el.parentElement !== aside) aside.appendChild(el);
    });
  }

  // initial check
  function handleMqChange(e) {
    if (e.matches) moveToMobile();
    else moveToAside();
    // ré-render éventuellement les selects / comptes si besoin
    // (les fonctions existent déjà dans votre script)
    if (typeof renderLocationFilters === 'function') renderLocationFilters();
    if (typeof renderFormatFilters === 'function') renderFormatFilters();
    if (typeof renderQuickFilters === 'function') renderQuickFilters();
  }

  // run once now
  handleMqChange(mql);

  // listen for changes (resize)
  if (mql.addEventListener) {
    mql.addEventListener('change', handleMqChange);
  } else if (mql.addListener) { // ancien Safari/IE fallback
    mql.addListener(handleMqChange);
  }
})();

</script>

  <script>


/* utils */
function isCode(s) { return /^[0-9]+$/.test(String(s)); }
function labelForCode(code) { return codeMap[String(code)] || String(code); }

/* construire parentMap et childrenMap (pour navigation) */
const parentMap = {};   // parentMap[code] = parentCode (string) or null
const childrenMap = {}; // childrenMap[parentCode] = [childCode,...]
Object.keys(codeMap).sort((a,b)=> a.length - b.length || a.localeCompare(b)).forEach(code=>{
  if (code.length === 1) {
    parentMap[code] = null;
  } else {
    const parent = code.slice(0, code.length - 1);
    parentMap[code] = codeMap[parent] ? parent : null;
  }
  // ensure childrenMap entry exists
  const p = parentMap[code] || "ROOT";
  if (!childrenMap[p]) childrenMap[p] = [];
  childrenMap[p].push(code);
});

/* helper : obtenir la chaîne d'étiquettes à partir d'un code (ex "131" -> ["Patrimoine bâti","Remarquable","Maisons remarquables"]) */
function codeToLabelChain(code) {
  code = String(code);
  const parts = [];
  for (let i=1;i<=code.length;i++){
    const key = code.slice(0,i);
    if (codeMap[key]) parts.push(codeMap[key]);
  }
  if (parts.length === 0 && codeMap[code]) return [codeMap[code]];
  return parts;
}

/* helper : collecter toutes les étiquettes (labels en lowercase) sous un chemin de codes.
   pathCodes = [] -> tout l'arbre; sinon on part du dernier code et on descend. */
function getLeavesUnderPath(pathCodes) {
  const leaves = new Set();

  // determine starting nodes
  let startCodes = [];
  if (!pathCodes || pathCodes.length === 0) {
    startCodes = childrenMap["ROOT"] ? childrenMap["ROOT"].slice() : [];
  } else {
    const last = String(pathCodes[pathCodes.length - 1]);
    if (!codeMap[last]) return []; // path invalide -> none
    startCodes = [last];
  }

  function recurse(code) {
    // ajouter le label du noeud
    if (codeMap[code]) leaves.add(String(codeMap[code]).toLowerCase());
    // descendre dans ses enfants
    const kids = childrenMap[code] || [];
    kids.forEach(k => recurse(k));
  }

  startCodes.forEach(c => recurse(c));
  return Array.from(leaves);
}

/* label -> code mapping rapide (utile pour migration et recherche) */
const labelToCodeMap = {};
Object.entries(codeMap).forEach(([c,l]) => labelToCodeMap[l.toLowerCase()] = c);

/* tentative de correspondance souple pour anciennes chaînes (ex "Mobilier urbain, Fonctionnel") */
function migrateRangementArray(oldArr) {
  if (!Array.isArray(oldArr)) return oldArr;
  const out = [];
  oldArr.forEach(entry=>{
    if (!entry) return;
    if (isCode(entry)) { out.push(entry); return; }
    // split possible "Parent, Child"
    const parts = String(entry).split(',').map(s=>s.trim()).filter(Boolean);
    if (parts.length >= 2) {
      const childLabel = parts[1].toLowerCase();
      if (labelToCodeMap[childLabel]) { out.push(labelToCodeMap[childLabel]); return; }
      const parentLabel = parts[0].toLowerCase();
      if (labelToCodeMap[parentLabel]) { out.push(labelToCodeMap[parentLabel]); return; }
    }
    // exact match full string
    const full = String(entry).toLowerCase();
    if (labelToCodeMap[full]) { out.push(labelToCodeMap[full]); return; }
    // fallback : keep original token (so nothing lost)
    out.push(entry);
  });
  return out;
}

/* escape pour onclick inline */
function escapeForOnClick(s) { return String(s).replace(/'/g,"\\'").replace(/"/g,'\\"'); }

/* ---------------- articles (exemples) ---------------- */
const articles = [
    {
    id: 1,
    annee: 2025,
    titre: "Panagía Kapnikaréa Church",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0661.webp", alt: "" }],
    note: "L'église de la Panagía Kapnikaréa (en grec moderne : Εκκλησία της Παναγίας Καπνικαρέας), souvent appelée simplement Kapnikaréa (Καπνικαρέα), est une église byzantine datant du troisième quart du XIe siècle, situé rue Ermoú, en plein cœur du centre historique d'Athènes.",
    rangement: ["712", "12", "111", "82"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Chat",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0675.webp", alt: "" }],
    note: "Les chats font partie intégrante du paysage urbain à Athènes, les habitants leur laissent de la nourriture dans tous les coins de rue.",
    coment: "chat apperçu à proximité de l'Agora Antique.",
    rangement: ["912"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
      {
    id: 1,
    annee: 2025,
    titre: "Agora romaine",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0676.webp", alt: "" }],
    note: "L'agora romaine d'Athènes était une place publique antique, servant à la fois de marché et de lieu de rassemblement. Il existait deux agoras distinctes à Athènes : l'agora classique, fondée au VIe siècle av. J.-C., et l'agora romaine, créée sous la domination romaine, un peu plus à l'est.",
    rangement: ["7111", "12", "814"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Plaka" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Koulouri stands",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0629.webp", alt: "Koulouri stand at Panepistimio" }],
    note: "Koulouri stands (or “koulouri”) are an iconic feature of the urban landscape of Athens. These small structures mainly sell koulouris, ring-shaped breads coated with sesame seeds, a typical Greek snack highly appreciated by both locals and tourists. The stands are ubiquitous in downtown Athens, especially in pedestrian areas such as Syntagma Square, Monastiraki, and the Agora.",    
    rangement: ["6","21"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
      {
    id: 1,
    annee: 2025,
    titre: "Arch of Hadrian",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0700.webp", alt: "" }],
    note: "L'Arc d'Hadrien (en grec : Αψίδα του Αδριανού, Apsida tou Adrianou), plus communément appelé la Porte d'Hadrien (Πύλη του Αδριανού, Pyli tou Adrianou), est un monumental portail inspiré des arcs de triomphe romains.",
    rangement: ["7113", "12", "814"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Le jour des 13 heures",
    type: ["Video"],
    note: "Athènes, 1ᵉʳ octobre 2025. La Grèce vit au ralenti : syndicats et travailleurs observent une grève générale contre la réforme autorisant des journées de travail de treize heures.\nCe film suit une journée de rassemblements et de voix qui résonnent place Syntagma.",
    link: "https://sous-les-titres.fr/films/le%20jour%20des%2013%20heures/le%20jour%20des%2013%20heures",
    rangement: ["511", "521", "522"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Graffiti anarchiste",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0642.webp", alt: "Graffiti anarchiste" }],
    note: "Graffiti anarchiste",
    coment: "Il est fréquent de retrouver ce graffiti sur le mobilier urbain ou à même les murs, dans bien des cas; lorsqu'ils sont effacés, ils sont reproduits les jours suivants.",
    rangement: ["521", "42"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Graffiti récurrent",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0709.webp", alt: "Graffiti anarchiste" }],
    note: "Il est fréquent de retrouver ce graffiti un peu partout à Athènes, à voir s'il a une signification particulière",
    coment: "L'inscription \"Man Spreading\" n'est pas présente sur les autres graffitis rencontrés.",
    rangement: ["42"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Nerantzies",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0628.webp", alt: "" }],
    note: "This is a species of orange tree that is used in urban settings and is for decorative purposes only",
    rangement: ["92"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2024,
    titre: "NOUS N'AVONS PAS PEUR DES RUINES",
    type: ["Video"],
    note: "Que se passe-t-il en Grèce ? Voici un film qui offre un autre regard que celui proposé par les médias dominants. Un regard depuis l'intérieur du mouvement social à Athènes, en Crète et jusqu'à Paros. Un voyage en musique au sein de collectifs grecs en lutte pour une société plus juste et plus solidaire.",
    link: "https://www.youtube.com/watch?v=W1IcUvKz-dE",
    rangement: ["511", "521", "522"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Exárcheia" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Stationnements Vélos",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0737.webp", alt: "" }],
    note: "Emplacements permettant le stationnement de vélos",
    coment: "Cette installation peut paraître étonnante, étant donné la faible utilisation du vélo à Athènes.",
    rangement: ["21", "32"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Bouche à incendie",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0717.webp", alt: "" }],
    note: "",
    rangement: ["22"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Dromeas (the runner) by Kostas",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0739.webp", alt: "" }],
    note: "Photo of Dromeas (the runner) by Kostas Varotsos from Evangelismos.",
    rangement: ["411"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Kolonaki" }
  },
  {
    id: 2,
    annee: 2025,
    titre: "Yellow Taxis",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0614.webp", alt: "Yellow Taxi at Syntagma" }],
    note: "Taxi jaunes",
    tags: ["taxi","moblity","cars"],
    rangement: ["311"],
    localisation: { position: "Athens" }
  },
  {
    id: 2,
    annee: 2025,
    titre: "Trottinettes électriques",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0730.webp", alt: "Trottinettes électriques" }],
    note: "Trottinettes électriques",
    rangement: ["32"],
    localisation: { position: "Athens" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Cabines téléphoniques abandonnées",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0639.webp", alt: "" }],
    note: "Ancinnes cabines téléphoniques, peu à peu démentelées",
    link: "https://fr.rua.gr/2025/08/19/fin-de-lere-des-taxophones-a-athenes-les-cabines-telephoniques-abandonnees-sont-massivement-supprimees/",
    rangement: ["21"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 3,
    annee: 2025,
    titre: "Mailboxes",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0637.webp", alt: "Mailboxe" }],
    note: "The mailboxes of Athens ...",
    tags: ["graffiti","activism","politic","anarchism"],
    rangement: ["214"],
    localisation: { position: "Athens" }
  }/*
  {
    id: 4,
    annee: 2025,
    titre: "Map of abandoned building of Athens",
    type: ["Map"],
    note: "Map of abandoned building of Athens",
    tags: ["building"],
    localisation: { position: "Athens", municipalite: "Athina" },
    rangement: ["142"],
    link: "lien"
  },
  {
    id: 5,
    annee: 2025,
    titre: "Carte des friches naturelles",
    type: ["Map"],
    note: "Carte des friches naturelles",
    tags: ["building"],
    localisation: { position: "Athens", municipalite: "Athina" },
    rangement: ["15"],
    link: "lien"
  }*/
];

/* --------- extraction de tags (compatible codes ou anciennes chaînes) --------- */
function getArticleTags(article) {
  if (!article || !Array.isArray(article.rangement) || article.rangement.length === 0) return [];
  const set = new Set();
  article.rangement.forEach(item => {
    if (isCode(item)) {
      const chain = codeToLabelChain(item);
      chain.forEach(c => set.add(String(c).toLowerCase()));
    } else {
      // ancienne logique: "Mobilier urbain, Fonctionnel"
      const chain = String(item).split(',').map(s=>s.trim()).filter(Boolean);
      chain.forEach(c => set.add(String(c).toLowerCase()));
    }
  });
  return Array.from(set);
}

/* ---------- filtrage / counts / rendu ---------- */
let activeTags = ["All"];
let activeFormats = ["All"];
let searchQuery = "";
let locPosition = "";
let locMunicipalite = "";
let locQuartier = "";
let currentLayerPath = []; // maintenant tableau de codes (ex ["1"] ou ["1","13"])

function getBaseForTagCounts() {
  let filtered = [...articles];
  if (searchQuery && searchQuery.trim() !== "") {
    const q = searchQuery.toLowerCase();
    filtered = filtered.filter(a => (a.titre + " " + (a.note||"") + " " + getArticleTags(a).join(" ")).toLowerCase().includes(q));
  }
  if (!activeFormats.includes("All") && activeFormats.length > 0) {
    filtered = filtered.filter(a => a.type && a.type.some(t => activeFormats.includes(t)));
  } else if (!activeFormats.includes("All") && activeFormats.length === 0) {
    filtered = [];
  }
  if (locPosition) filtered = filtered.filter(a => a.localisation?.position === locPosition);
  if (locMunicipalite) filtered = filtered.filter(a => a.localisation?.municipalite === locMunicipalite);
  if (locQuartier) filtered = filtered.filter(a => a.localisation?.quartier === locQuartier);
  return filtered;
}

function countArticlesForLeaves(leaves) {
  if (!leaves || leaves.length === 0) return 0;
  const base = getBaseForTagCounts();
  return base.filter(a => {
    const at = getArticleTags(a);
    return at && at.some(t => leaves.includes(String(t).toLowerCase()));
  }).length;
}

function applyFilters() {
  renderQuickFilters();
  renderFormatFilters();
  let result = [...articles];
  if (searchQuery.trim() !== "") {
    result = result.filter(a => (a.titre + " " + (a.note||"") + " " + getArticleTags(a).join(" ")).toLowerCase().includes(searchQuery));
  }
  if (!activeTags.includes("All") && activeTags.length > 0) {
    result = result.filter(a => {
      const atags = getArticleTags(a);
      return atags && atags.some(tag => activeTags.includes(tag));
    });
  } else if (!activeTags.includes("All") && activeTags.length === 0) {
    result = []; // aucun tag sélectionné → rien n'affiche
  }
  if (!activeFormats.includes("All") && activeFormats.length > 0) {
    result = result.filter(a => a.type && a.type.some(type => activeFormats.includes(type)));
  } else if (!activeFormats.includes("All") && activeFormats.length === 0) {
    result = [];
  }
  if (locPosition) result = result.filter(a => a.localisation?.position === locPosition);
  if (locMunicipalite) result = result.filter(a => a.localisation?.municipalite === locMunicipalite);
  if (locQuartier) result = result.filter(a => a.localisation?.quartier === locQuartier);
  renderArticles(result);
}

/* format filters */
function getAllFormats(articles) {
  const set = new Set();
  articles.forEach(a => a.type.forEach(f => set.add(f)));
  return [...set];
}
function getFilteredForCounts() {
  let filtered = [...articles];
  if (searchQuery && searchQuery.trim() !== "") {
    const q = searchQuery.toLowerCase();
    filtered = filtered.filter(a => (a.titre + " " + (a.note||"") + " " + getArticleTags(a).join(" ")).toLowerCase().includes(q));
  }
  if (!activeTags.includes("All") && activeTags.length > 0) {
    filtered = filtered.filter(a => {
      const at = getArticleTags(a);
      return at && at.some(tag => activeTags.includes(tag));
    });
  } else if (!activeTags.includes("All") && activeTags.length === 0) {
    filtered = [];
  }
  if (locPosition) filtered = filtered.filter(a => a.localisation?.position === locPosition);
  if (locMunicipalite) filtered = filtered.filter(a => a.localisation?.municipalite === locMunicipalite);
  if (locQuartier) filtered = filtered.filter(a => a.localisation?.quartier === locQuartier);
  return filtered;
}
function filterFormat(format) {
  const buttons = document.querySelectorAll("#formatFilters button");
  if (format === "All") {
    activeFormats = ["All"];
  } else {
    activeFormats = activeFormats.filter(f => f !== "All");
    if (activeFormats.includes(format)) activeFormats = activeFormats.filter(f => f !== format);
    else activeFormats.push(format);
  }
  buttons.forEach(b => { const fmt = b.dataset.format; b.classList.toggle("active", activeFormats.includes(fmt)); });
  applyFilters();
}
function renderFormatFilters() {
  const container = document.getElementById("formatFilters");
  const formats = ["All", ...getAllFormats(articles)];
  const filteredForCounts = getFilteredForCounts();
  const counts = {};
  counts["All"] = filteredForCounts.length;
  formats.slice(1).forEach(f => counts[f] = filteredForCounts.filter(a => a.type && a.type.includes(f)).length);
  container.innerHTML = formats.map(f => {
    const n = counts[f] || 0;
    return `<button data-format="${f}" onclick="filterFormat('${f}')">${f} (${n})</button>`;
  }).join("");
  container.querySelectorAll("button").forEach(b => {
    const fmt = b.dataset.format; b.classList.toggle("active", activeFormats.includes(fmt));
  });
}

/* --------- render articles ---------- */
function renderArticles(data = articles) {
  const list = document.getElementById("list");
  list.innerHTML = "";
  data.forEach(article => {
    let imagesHTML = "";
    if (article.images && article.images.length) {
      imagesHTML = article.images.map(img => `
        <figure>
          <img class="thumb" src="${img.url}" alt="${img.alt}">
          <figcaption>${img.alt}</figcaption>
        </figure>
      `).join("");
    }

const tagsHtml = (article.rangement || []).map(codeOrLabel=>{
  let labels = [];
  if (isCode(codeOrLabel)) labels = codeToLabelChain(codeOrLabel);
  else labels = String(codeOrLabel).split(',').map(s=>s.trim());

  const fullTitle = labels.join(" -> ");
  // crée un lien par élément de la hiérarchie (chaque niveau cliquable)
  const links = labels.map((lbl, idx) => {
    const escaped = escapeForOnClick(lbl);
    return `<a href="#" class="tag-link" onclick="filterTag('${escaped}'); return false;">${lbl}</a>`;
  }).join('<span class="sep"> -> </span>');

  return `
    <p class="tag-line" title="${fullTitle}">
      ${links}
    </p>
  `;
}).join("");



    const html = `
      <details class="item">
        <summary>
          <span>+ ${article.annee} — ${article.titre}</span>
          <span style="font-size:12px;color:var(--muted)">${article.type.join(", ")}</span>
        </summary>

        <div class="details-body">
          ${imagesHTML}
          <div class="info">
            <div>
              <p style="white-space: pre-wrap"><strong>Note:</strong><br>${article.note}</p>
              ${ article.link ? `<p><strong>Link:</strong> <a href="${article.link}" target="_blank">${article.link}</a></p>` : "" }

              ${ article.coment ? `<p class="comment"><strong>Coment:</strong> ${article.coment}</p>` : "" }

              ${ article.sources?.length ? `<p><strong>Sources :</strong></p>
                 <ul>${article.sources.map(src => src.url ? `<li><a href="${src.url}" target="_blank">${src.title}</a></li>` : `<li>${src.title}</li>`).join("")}</ul>` : "" }

              <div class="meta-tags">
                <strong>Tags:</strong>${tagsHtml}
              </div>
            </div>

            ${ article.localisation ? `
              <div class="meta-small">
                <strong>Localisation :</strong><br>
                ${[ article.localisation.position, article.localisation.municipalite, article.localisation.quartier ].filter(Boolean).join(", ")}
              </div>
            ` : "" }
          </div>
        </div>
      </details>
    `;
    list.insertAdjacentHTML("beforeend", html);
  });
}

/* ---------- Quick Filters (drilldown) ---------- */
function enterLayer(code) {
  // code attendu : string code (ex "1" ou "13")
  if (!codeMap[code]) return;
  currentLayerPath.push(code);
  const leaves = getLeavesUnderPath(currentLayerPath);
  if (leaves.length) activeTags = [...leaves];
  else activeTags = activeTags.filter(t => t !== "All");
  applyFilters();
  renderQuickFilters();
}
function goUpLayer() {
  currentLayerPath.pop();
  if (currentLayerPath.length === 0) activeTags = ["All"];
  else {
    activeTags = getLeavesUnderPath(currentLayerPath);
    if (activeTags.length === 0) activeTags = ["All"];
  }
  applyFilters();
  renderQuickFilters();
}
function resetLayer() {
  currentLayerPath = [];
  activeTags = ["All"];
  applyFilters();
  renderQuickFilters();
}
function toggleLeafTag(leaf) {
  const tag = String(leaf).toLowerCase();
  activeTags = activeTags.filter(t => t !== "All");
  if (activeTags.includes(tag)) activeTags = activeTags.filter(t => t !== tag);
  else activeTags.push(tag);
  applyFilters();
  renderQuickFilters();
}

/* build root codes array */
const rootCodes = childrenMap["ROOT"] ? childrenMap["ROOT"].slice() : [];

function renderQuickFilters() {
  const container = document.getElementById("quickFilters");
  if (!container) return;
  const baseForCounts = getBaseForTagCounts();
  const allCount = baseForCounts.length;
  let html = `<button data-tag="All" onclick="resetLayer()">All (${allCount})</button>`;

  if (currentLayerPath.length === 0) {
    html += "<div style='width:100%;height:6px'></div>";
    rootCodes.forEach(rootCode => {
      const leaves = getLeavesUnderPath([rootCode]);
      const n = countArticlesForLeaves(leaves);
      if (n === 0) return;
      html += `<button data-parent="${escapeForOnClick(rootCode)}" onclick="enterLayer('${escapeForOnClick(rootCode)}')">${labelForCode(rootCode)} (${n})</button>`;
    });
  } else {
    // chemin courant + bouton retour
    const chainLabels = currentLayerPath.map(c=>labelForCode(c)).join(' -> ');
    html += `<button onclick="goUpLayer()" class="active">${chainLabels}</button>`;
    const nodeCode = currentLayerPath[currentLayerPath.length - 1];
    const children = childrenMap[nodeCode] || [];
    children.forEach(childCode => {
      const leaves = getLeavesUnderPath([...currentLayerPath, childCode]);
      const n = countArticlesForLeaves(leaves);
      if (n === 0) return;
      html += `<button data-child="${escapeForOnClick(childCode)}" onclick="enterLayer('${escapeForOnClick(childCode)}')">${labelForCode(childCode)} (${n})</button>`;
    });
  }

  container.innerHTML = html;

  // mark active parent button if at first level
  if (currentLayerPath.length === 1) {
    container.querySelectorAll("button[data-parent]").forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-parent") === currentLayerPath[0]);
    });
  }
}

/* --------- filterTag: gère labels et codes ---------- */
function findCodeByLabel(label) {
  if (!label) return null;
  const lower = String(label).toLowerCase();
  // 1) quick map
  if (labelToCodeMap[lower]) return labelToCodeMap[lower];
  // 2) exact match among codeMap values
  for (const [c,l] of Object.entries(codeMap)) {
    if (String(l).toLowerCase() === lower) return c;
  }
  return null;
}

function filterTag(tag) {
  const lower = String(tag).toLowerCase();

  // 1) si tag correspond exactement à un label connu -> bascule code / entrée dans layer
  const code = findCodeByLabel(tag);
  if (code) {
    // si code est une racine ou un parent: entrer dans sa couche
    enterLayer(code);
    return;
  }

  // 2) si tag apparaît dans les feuilles connues -> toggle
  const allLeaves = getLeavesUnderPath([]);
  if (allLeaves.includes(lower)) {
    toggleLeafTag(lower);
    return;
  }

  // 3) fallback : toggle simple (conserver ancien comportement)
  toggleLeafTag(lower);
}

/* ---------- location helpers ---------- */
function getAllLocations(articles) {
  const positions = new Set();
  const municipalites = new Set();
  const quartiers = new Set();
  articles.forEach(a => {
    if (a.localisation) {
      if (a.localisation.position) positions.add(a.localisation.position);
      if (a.localisation.municipalite) municipalites.add(a.localisation.municipalite);
      if (a.localisation.quartier) quartiers.add(a.localisation.quartier);
    }
  });
  return { positions: [...positions], municipalites: [...municipalites], quartiers: [...quartiers] };
}
function renderLocationFilters() {
  const posSel = document.getElementById("positionFilter");
  const munSel = document.getElementById("municipaliteFilter");
  const quaSel = document.getElementById("quartierFilter");
  posSel.innerHTML = `<option value="">Position</option>`;
  munSel.innerHTML = `<option value="">Municipality</option>`;
  quaSel.innerHTML = `<option value="">Neighborhood</option>`;
  const allPositions = new Set();
  articles.forEach(a => { if (a.localisation?.position) allPositions.add(a.localisation.position); });
  allPositions.forEach(p => posSel.insertAdjacentHTML("beforeend", `<option value="${p}">${p}</option>`));
  let filteredByPosition = articles;
  if (locPosition) filteredByPosition = filteredByPosition.filter(a => a.localisation?.position === locPosition);
  const municipalites = new Set();
  filteredByPosition.forEach(a => { if (a.localisation?.municipalite) municipalites.add(a.localisation.municipalite); });
  municipalites.forEach(m => munSel.insertAdjacentHTML("beforeend", `<option value="${m}">${m}</option>`));
  let filteredByPosAndMun = filteredByPosition;
  if (locMunicipalite) filteredByPosAndMun = filteredByPosAndMun.filter(a => a.localisation?.municipalite === locMunicipalite);
  const quartiers = new Set();
  filteredByPosAndMun.forEach(a => { if (a.localisation?.quartier) quartiers.add(a.localisation.quartier); });
  quartiers.forEach(q => quaSel.insertAdjacentHTML("beforeend", `<option value="${q}">${q}</option>`));
  if (!allPositions.has(locPosition)) locPosition = "";
  if (!municipalites.has(locMunicipalite)) locMunicipalite = "";
  if (!quartiers.has(locQuartier)) locQuartier = "";
  posSel.value = locPosition;
  munSel.value = locMunicipalite;
  quaSel.value = locQuartier;
}
function filterLocation() {
  locPosition = document.getElementById("positionFilter").value;
  locMunicipalite = document.getElementById("municipaliteFilter").value;
  locQuartier = document.getElementById("quartierFilter").value;
  renderLocationFilters();
  applyFilters();
}
function filterList() {
  const v = document.getElementById('searchbox').value || "";
  searchQuery = v.trim().toLowerCase();
  applyFilters();
}
function resetFilters() {
  locPosition = ""; locMunicipalite = ""; locQuartier = "";
  ['positionFilter','municipaliteFilter','quartierFilter'].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
  const sb = document.getElementById('searchbox'); if (sb) sb.value = "";
  searchQuery = "";
  activeFormats = ["All"];
  document.querySelectorAll('#list details[open]').forEach(d => d.removeAttribute('open'));
  resetLayer();
  renderFormatFilters();
  renderLocationFilters();
  applyFilters();
}

/* sort */
function sortBy(mode){
  const list = document.getElementById('list');
  const items = Array.from(list.querySelectorAll('.item'));
  if(mode === 'date'){
    items.sort((a,b)=>{
      const da = (a.innerText.match(/\b(19|20)\d{2}\b/)||['9999'])[0];
      const db = (b.innerText.match(/\b(19|20)\d{2}\b/)||['9999'])[0];
      return parseInt(db) - parseInt(da);
    });
  }
  items.forEach(i=>list.appendChild(i));
}

/* initial render */
renderQuickFilters();
renderFormatFilters();
renderLocationFilters();
renderArticles();

  </script>
</body>
</html>


