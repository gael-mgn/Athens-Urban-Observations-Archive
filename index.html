<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Athens Urban Observations Archive — AUOA</title>
  <meta name="description" content="Athens Urban Observations Archive (AUOA) is a digital archive dedicated to documenting and studying the city of Athens in all its dimensions: historical, social, cultural, and architectural." />
  <meta name="keywords" content="Athens, Urban Observations, Urbanism, Archive, digital archive">
  <meta property="og:image" content="athens-urban-observations-archive.webp" />
  <style>
:root{
  --bg:#fdfdfd;
  --ink:#000;
  --ink-mute:#777;
  --panel:#f4f4f4;
  --line:2px solid #000;
  --gap:32px;
  --radius:0;
  --font-sans:"Inter", "Helvetica Neue", Arial, sans-serif;
  --font-serif:"Inter", "Helvetica Neue", Arial, sans-serif;
}
a { color: var(--ink); }
html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font-family:var(--font-sans);font-size:16px;line-height:1.4;}
body{padding:40px;}
*{box-sizing:border-box;letter-spacing:-0.01em;}
.wrap{ max-width:1240px; margin:0 auto; display:grid; grid-template-columns:1fr 380px; gap:var(--gap); }
header{ grid-column:1/-1; border-bottom:var(--line); padding-bottom:16px; display:flex; justify-content:space-between; align-items:flex-end; }
.site-title{ font-family:var(--font-serif); font-size:26px; font-weight:700; margin-bottom:4px; }
header small{font-size:12px;color:var(--ink-mute)}
nav{display:flex;gap:18px;}
nav a{ text-decoration:none; color:var(--ink); font-weight:600; padding:6px 0; border-bottom:2px solid transparent; }
nav a:hover{ border-bottom:2px solid var(--ink); }
.hero{ padding:38px 32px; background:var(--panel); border:var(--line); display:flex;flex-direction:column; gap:18px; }
.hero h1{ margin:0; font-family:var(--font-serif); font-size:40px; line-height:1.1; }
.hero p{margin:0;color:var(--ink-mute);max-width:70%;font-size:15px;}
.hero .cta{ padding:12px 18px; border:var(--line); background:#fff; font-weight:800; text-transform:uppercase; }
.hero .cta:hover{ background:var(--ink); color:#fff; }
.archive{ border:var(--line); padding:20px; background:#fff; }
.controls{ display:flex; flex-wrap:wrap; gap:12px; margin-bottom:20px; }
.controls input[type=search]{ flex:1; padding:12px; border:var(--line); font-family:var(--font-sans); }
input[type="checkbox"] { accent-color: black; }
.controls button{ padding:12px 14px; border:var(--line); background:#fff; font-weight:700; text-transform:uppercase; cursor:pointer; }
.controls button:hover{ background:var(--ink); color:#fff; }
.list{display:flex;flex-direction:column;gap:22px;}
.item{ border:var(--line); background:#fafafa; padding:0; }
.item summary { cursor: pointer; list-style: none; padding: 16px 18px; border-bottom: var(--line); display: flex; justify-content: space-between; font-weight: 800; font-size: 15px; gap: 20px; transition: background-color 0.4s ease, color 0.4s ease; }
.item summary:hover { background: black; color: white; }
.item summary::-webkit-details-marker{display:none;}
.details-body{ padding:20px; }
.thumb{ width:100%; object-fit:cover; border:var(--line); }

/*.thumb {
  width: 100%;
  max-height: 500px;
  object-fit: contain;
  border: var(--line);
}*/

figure { margin: 0; padding: 0; margin-bottom: 10px; }
figcaption { font-size: 13px; color: var(--ink-mute); }
.info{ display:grid; grid-template-columns:1fr 150px; gap:18px; }
.info a {
  word-break: break-all; /* Permet de couper le texte en plein mot si nécessaire */
    overflow-wrap: break-word; /* Gère les retours à la ligne si le texte est trop long */
    max-width: 100%; 
}
.meta-tags{ margin-top:10px; }
.tag{ padding:4px 8px; border:var(--line); background:#fff; font-size:11px; font-weight:700; cursor:pointer; }
.tag:hover{ background:var(--ink); color:#fff; }
#quickFilters button { cursor:pointer; }
#quickFilters button.active, #formatFilters button.active { background: black; color: white; border-color: black; }
.meta-small{font-size:13px;color:var(--ink-mute);}
.coment { margin-top:10px; font-size:14px; color:var(--ink); white-space: pre-wrap; }
aside { position: sticky; top: 20px; max-height: calc(150vh); }
.meta{ border:var(--line); padding:18px; background:#fff; }
.meta select { width: 100%; padding: 6px 8px; margin-bottom: 8px; border: var(--line); background: #fff; font-size: 13px; }
.meta h3{ margin-top:0; font-size:14px; letter-spacing:0; }
.meta button{ padding:6px 10px; border:var(--line); background:#fff; font-size:12px; font-weight:700; }
.meta button:hover{ background:var(--ink); color:#fff; }
.tag-line {margin: 0; padding: 0; display: block; }
.sep { text-decoration: none; }
.tag-link { text-decoration: underline; }

/* --- affichage tags par axe (visu groupée) --- */
.tag-line { display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap; }
.axis { font-weight:800; font-size:12px; min-width:44px; display:inline-block; color:var(--ink); }
.tag-hierarchy { display:inline-block; }
.sep { margin: 0 8px; color: var(--ink-mute); text-decoration: none; }
.tag-hierarchy .tag-link { text-decoration: underline; font-weight:700; font-size:12px; }


footer{ grid-column:1/-1; border-top:var(--line); padding-top:16px; margin-top:32px; display:flex; justify-content:space-between; font-size:14px; }
@media(max-width:980px){
  .no-mobile { display: none; }
  body{padding:20px;}
  .wrap{grid-template-columns:1fr;}
  aside{order:3;margin-top:0px;}
  aside { position: relative; }
  .archive{order:2;}
  .hero{order:1;}
  .info{grid-template-columns:1fr;}
  .hero p{max-width:100%;}
}
@media(max-width:980px){
  .controls input[type=search]{ width: 100%; }
}

/* container mobile: invisible sur desktop, visible sur mobile */
.mobile-filters { display: none; margin: 18px 0; gap: 12px; }
@media (max-width:980px) {
  .mobile-filters { display: block; }
  /* spacing / box look similaire aux .meta */
  .mobile-filters .meta { border: var(--line); padding: 12px; background: #fff; margin-bottom: 12px; }
  /* rendre select/buttons plus larges si besoin */
}

/* Desktop only: make list a fixed-scroll area */
@media (min-width: 981px) {
  /* wrapper: ensure archive doesn't overflow */
  .archive {
    overflow: visible; /* permet au .list de scroller indépendamment */
  }

  /* zone scrollable pour la liste d'articles */
  #list {
    overflow: auto;           /* affichage du scroll quand nécessaire */
    -webkit-overflow-scrolling: touch;
    /* valeur par défaut au cas où JS est désactivé : ajuste le 500px selon préférence */
    max-height: 85vh;
    padding-right: 8px;       /* évite que le contenu touche le bord quand scrollbar visible */
  }
}

  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div>
          <div class="site-title" style="font-weight: bold;">Athens Urban Observations Archive</div>
          <div style="font-size:12px;color:var(--muted)">An Online Ethnographic and Urban Repository on Athenian Spaces in Transition</div>
        </div>
      </div>
      <nav aria-label="Navigation principale" class="no-mobile">
        <a href="">Project</a>
        <a href="#about">About</a>
        <a href="#contact">Contact</a>
      </nav>
    </header>

    <main>
      <section class="hero" aria-labelledby="hero-title">
        <h1 id="hero-title">Athens Urban Observations Archive :<br>
An Online Ethnographic and Urban Repository on Athenian Spaces in Transition</h1>
        <p>The project aims to create a collaborative online archive documenting subtle, overlooked, or transitional spaces of Athens. It blends urban studies, ethnography, visual culture, and citizen contributions to build a living memory of the city’s informal, contested, or reappropriated places.</p>
      </section>

      <!-- insérer directement après </section> de .hero -->
      <div id="mobileFilters" class="mobile-filters" aria-hidden="true"></div>


      <section id="archives" class="archive" aria-labelledby="archives-title">
        <div class="controls">
          <input id="searchbox" type="search" placeholder="Search" oninput="filterList()" />
          <button onclick="resetFilters()">Reset filters</button>
          <button onclick="sortBy('date')" class="no-mobile">Sort by date</button>
        </div>

        <div id="list" class="list" role="list"></div>
      </section>
    </main>

    <aside>
      <div class="meta">
        <h3>Quick filters</h3>
        <p style="margin-bottom: 0;">Click on a tag in the list below to filter the results. (<a href="thesaurus.html">classification index</a>)</p>
        <div id="quickFilters" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"></div>
      </div>

      <div style="height:16px"></div>

      <div class="meta">
        <h3>Localisation</h3>
        <select id="positionFilter" onchange="filterLocation()"></select>
        <select id="municipaliteFilter" onchange="filterLocation()"></select>
        <select id="quartierFilter" onchange="filterLocation()"></select>
      </div>

      <div style="height:16px"></div>

      <div class="meta">
        <h3>Format</h3>
        <div id="formatFilters" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"></div>
      </div>

      <div style="height:16px"></div>
    </aside>

    <footer>
      <div>© <strong>Athens Urban Observations Archive</strong> — <span id="year"></span></div>
      <script>document.getElementById("year").textContent = new Date().getFullYear();</script>
    </footer>
  </div>


<script src="data/codemap.js">

</script>

<script>




/* ---------- Transformation automatique des clés numériques en format LETTRE.points (ex: T.1.1) ---------- 
   - conserve l'objet `thesaurus` tel quel dans le source JS (pas besoin de réécrire manuellement),
   - puis on remplace *dynamiquement* les clés numériques par des clés de la forme AXE.d1.d2...
   - axes: T = Thématique (1,2,3,4,5,6,9), A = Architecture (7), C = Chronologie (8)
*/

/*
(function transformThesaurusKeys(){
  const axisMap = { '7': 'A', '8': 'C' }; // autres -> 'T'
  // clone l'ancien objet puis vide le thesaurus (on mutera l'objet const)
  const original = Object.assign({}, thesaurus);
  Object.keys(thesaurus).forEach(k => delete thesaurus[k]);

  Object.entries(original).forEach(([key, value]) => {
    if (/^[0-9]+$/.test(String(key))) {
      // transforme "7111" -> "A.7.1.1.1" (lettre d'axe + points entre chaque chiffre)
      const digits = String(key).split('');
      const axis = axisMap[digits[0]] || 'T';
      const newKey = axis + '.' + digits.join('.');
      thesaurus[newKey] = value;
    } else {
      // conserve toute clé déjà non-numérique
      thesaurus[key] = value;
    }
  });
})();*/



/* ---------- calcul dynamique des axes (après extractLabels) ---------- */
/* ---------- calcul dynamique des axes (après extractLabels) ----------
   Génère les axes à partir des clés top-level du `thesaurus` (ex: "A","T","C"),
   récupère leur label depuis thesaurus[<AXE>].label et rassemble les racines
   (clés à deux segments comme "T.1", "A.1", etc.).
*/
const axes = (function computeAxes(){
  const base = {};

  // 1) détecte toutes les clés top-level du thesaurus qui sont une lettre (ex "A","T","C")
  Object.keys(thesaurus).forEach(topKey => {
    if (/^[A-Z]$/.test(topKey)) {
      base[topKey] = {
        key: topKey,
        label: (thesaurus[topKey] && thesaurus[topKey].label) ? thesaurus[topKey].label : `Axe ${topKey}`,
        roots: []
      };
    }
  });

  // 2) parcourt les codes calculés (codeMap) et rattache les racines (deux segments) à leur axe
  Object.keys(codeMap).forEach(k => {
    const parts = k.split('.');
    if (parts.length === 2) {
      const axisLetter = parts[0];
      if (base[axisLetter]) base[axisLetter].roots.push(k);
    }
  });

  // 3) tri optionnel des racines pour stabilité d'affichage
  Object.values(base).forEach(ax => {
    ax.roots.sort((a,b) => a.localeCompare(b, undefined, {numeric: true}));
  });

  return base;
})();


let currentAxis = null;

</script>

<script>
  /* --- Responsive : déplacer les .meta de aside vers #mobileFilters sur mobile --- */
(function(){
  const MOBILE_QUERY = '(max-width:980px)';
  const mql = window.matchMedia(MOBILE_QUERY);
  const aside = document.querySelector('aside');
  const mobileContainer = document.getElementById('mobileFilters');

  if (!aside || !mobileContainer) return;

  // capture order initiale (NodeList -> Array)
  const metas = Array.from(aside.querySelectorAll('.meta'));

  // helper : move elements into container (preserve nodes)
  function moveToMobile() {
    if (!metas || metas.length === 0) return;
    // set aria
    mobileContainer.setAttribute('aria-hidden','false');
    metas.forEach(el => {
      // avoid moving if already moved
      if (el.parentElement !== mobileContainer) mobileContainer.appendChild(el);
    });
  }

  // helper : move elements back to aside (restaure ordre initial)
  function moveToAside() {
    if (!metas || metas.length === 0) return;
    mobileContainer.setAttribute('aria-hidden','true');
    metas.forEach(el => {
      // append back to aside (restaure ordre)
      if (el.parentElement !== aside) aside.appendChild(el);
    });
  }

  // initial check
  function handleMqChange(e) {
    if (e.matches) moveToMobile();
    else moveToAside();
    // ré-render éventuellement les selects / comptes si besoin
    // (les fonctions existent déjà dans votre script)
    if (typeof renderLocationFilters === 'function') renderLocationFilters();
    if (typeof renderFormatFilters === 'function') renderFormatFilters();
    if (typeof renderQuickFilters === 'function') renderQuickFilters();
  }

  // run once now
  handleMqChange(mql);

  // listen for changes (resize)
  if (mql.addEventListener) {
    mql.addEventListener('change', handleMqChange);
  } else if (mql.addListener) { // ancien Safari/IE fallback
    mql.addListener(handleMqChange);
  }
})();

</script>

  <script>


/* utils */
/* accepte :
   - anciens codes numériques (ex "7111")
   - nouveaux codes avec lettre + points (ex "A.7.1.1")
*/
function isCode(s) {
  const str = String(s).trim();
  if (!str) return false;
  if (/^[A-Z]$/.test(str)) return true; // ex: "A" ou "T" (axe)
  return /^[A-Z]\.\d+(?:\.\d+)*$/.test(str); // ex: "T.1", "A.1.1"
}
function labelForCode(code) { return codeMap[String(code)] || String(code); }

/* construire parentMap et childrenMap (compatible ancien & nouveau format pointé) */
const parentMap = {};   
const childrenMap = {}; 

Object.keys(codeMap).sort((a,b) => {
  const aDepth = a.split('.').length;
  const bDepth = b.split('.').length;
  return aDepth - bDepth || a.localeCompare(b);
}).forEach(code => {
  const parts = code.split('.');
  if (parts.length === 1) {
    parentMap[code] = null;
  } else {
    const parent = parts.slice(0, parts.length - 1).join('.');
    parentMap[code] = codeMap[parent] ? parent : null;
  }
  const p = parentMap[code] || "ROOT";
  if (!childrenMap[p]) childrenMap[p] = [];
  childrenMap[p].push(code);
});






/* convertit un ancien code numérique en format pointé avec lettre d'axe */
function numericToDotted(code) {
  const str = String(code);
  if (!/^[0-9]+$/.test(str)) return str;
  const digits = str.split('');
  const axis = (digits[0] === '7') ? 'A' : (digits[0] === '8') ? 'C' : 'T';
  return axis + '.' + digits.join('.');
}

/* normalise toute entrée possible en clé réellement présente dans codeMap :
   - si entrée est numérique -> convertit en dotted
   - si entrée est dotted sans lettre -> essaie d'ajouter lettre (rare)
   - si clé existe déjà dans codeMap, la retourne telle quelle
*/
function normalizeInputCode(raw) {
  if (!raw) return null;
  const s = String(raw);
  if (codeMap[s]) return s;               // déjà une clé valide
  if (/^[0-9]+$/.test(s)) {
    const dotted = numericToDotted(s);
    if (codeMap[dotted]) return dotted;
    return dotted; // fallback (même si pas dans codeMap)
  }
  // dotted style but starting with digit: "7.1.1" -> try adding axis letter
  if (/^\d+\./.test(s)) {
    const compact = s.replace(/\./g,'');
    const dotted = numericToDotted(compact);
    if (codeMap[dotted]) return dotted;
    return dotted;
  }
  return s;
}

function codeToLabelChain(rawCode) {
  let code = String(rawCode).trim();


  const parts = code.split('.');
  const acc = [];
  if (parts.length === 1) {
    if (codeMap[code]) return [codeMap[code]];
    return [];
  }
  for (let i = 2; i <= parts.length; i++) {
    const key = parts.slice(0, i).join('.');
    if (codeMap[key]) acc.push(codeMap[key]);
  }
  if (acc.length === 0 && codeMap[code]) return [codeMap[code]];
  return acc;
}



/* helper : collecter toutes les étiquettes (labels en lowercase) sous un chemin de codes.
   pathCodes = [] -> tout l'arbre; sinon on part du dernier code et on descend. */
function getLeavesUnderPath(pathCodes) {
  const leaves = new Set();

  // determine starting nodes
  let startCodes = [];
  if (!pathCodes || pathCodes.length === 0) {
    startCodes = childrenMap["ROOT"] ? childrenMap["ROOT"].slice() : [];
  } else {
    const last = String(pathCodes[pathCodes.length - 1]);
    if (!codeMap[last]) return []; // path invalide -> none
    startCodes = [last];
  }

  function recurse(code) {
    // ajouter le label du noeud
    if (codeMap[code]) leaves.add(String(codeMap[code]).toLowerCase());
    // descendre dans ses enfants
    const kids = childrenMap[code] || [];
    kids.forEach(k => recurse(k));
  }

  startCodes.forEach(c => recurse(c));
  return Array.from(leaves);
}

/* label -> code mapping rapide (utile pour migration et recherche) */
const labelToCodeMap = {};
Object.entries(codeMap).forEach(([c,l]) => labelToCodeMap[l.toLowerCase()] = c);

/* tentative de correspondance souple pour anciennes chaînes (ex "Mobilier urbain, Fonctionnel") */
function migrateRangementArray(oldArr) {
  if (!Array.isArray(oldArr)) return oldArr;
  const out = [];
  oldArr.forEach(entry=>{
    if (!entry) return;
    if (isCode(entry)) { out.push(entry); return; }
    // split possible "Parent, Child"
    const parts = String(entry).split(',').map(s=>s.trim()).filter(Boolean);
    if (parts.length >= 2) {
      const childLabel = parts[1].toLowerCase();
      if (labelToCodeMap[childLabel]) { out.push(labelToCodeMap[childLabel]); return; }
      const parentLabel = parts[0].toLowerCase();
      if (labelToCodeMap[parentLabel]) { out.push(labelToCodeMap[parentLabel]); return; }
    }
    // exact match full string
    const full = String(entry).toLowerCase();
    if (labelToCodeMap[full]) { out.push(labelToCodeMap[full]); return; }
    // fallback : keep original token (so nothing lost)
    out.push(entry);
  });
  return out;
}

/* escape pour onclick inline */
function escapeForOnClick(s) { return String(s).replace(/'/g,"\\'").replace(/"/g,'\\"'); }

/* ---------------- articles (exemples) ---------------- */
const articles = [
  {
    id: 1,
    annee: 2025,
    titre: "St. Catherine's Church",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0691.webp", alt: "" }],
    note: "The Church of St. Catherine in Athens (Greek: Ναός Αγίας Αικατερίνης / Naós Agías Ekaterínis) is a Byzantine-style religious building located in the Pláka district of Athens. Its construction is roughly dated to the first half of the 11th century. The church was dedicated to Saint Catherine of Alexandria when it was affiliated with the Monastery of St. Catherine in Sinai in 1767.",
    rangement: ["A.1.1.1", "A.1.2", "C.1.2", "C.3.1", "T.2"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Pláka" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Koulouri stands",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0629.webp", alt: "Koulouri stand at Panepistimio" }],
    note: "Koulouri stands (or “koulouri”) are an iconic feature of the urban landscape of Athens. These small structures mainly sell koulouris, ring-shaped breads coated with sesame seeds, a typical Greek snack highly appreciated by both locals and tourists. The stands are ubiquitous in downtown Athens, especially in pedestrian areas such as Syntagma Square, Monastiraki, and the Agora.",    
    rangement: ["A.6", "A.2.1", "C.3.4", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Panagía Kapnikaréa Church",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0661.webp", alt: "" }],
    note: "L'église de la Panagía Kapnikaréa (en grec moderne : Εκκλησία της Παναγίας Καπνικαρέας), souvent appelée simplement Kapnikaréa (Καπνικαρέα), est une église byzantine datant du troisième quart du XIe siècle, situé rue Ermoú, en plein cœur du centre historique d'Athènes.",
    rangement: ["A.1.1.1", "A.1.2", "C.1.2", "C.3.1", "T.2"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Chat",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0675.webp", alt: "" }],
    note: "Les chats font partie intégrante du paysage urbain à Athènes, les habitants leur laissent de la nourriture dans tous les coins de rue.",
    coment: "chat apperçu à proximité de l'Agora romaine.",
    rangement: ["A.7.1.2", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Agora romaine",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0676.webp", alt: "" }],
    note: "L'agora romaine d'Athènes était une place publique antique, servant à la fois de marché et de lieu de rassemblement. Il existait deux agoras distinctes à Athènes : l'agora classique, fondée au VIe siècle av. J.-C., et l'agora romaine, créée sous la domination romaine, un peu plus à l'est.",
    rangement: ["C.1.1.1", "A.1.2", "T.1.4"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Pláka" }
  },
        {
    id: 1,
    annee: 2025,
    titre: "Arch of Hadrian",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0700.webp", alt: "" }],
    note: "L'Arc d'Hadrien (en grec : Αψίδα του Αδριανού, Apsida tou Adrianou), plus communément appelé la Porte d'Hadrien (Πύλη του Αδριανού, Pyli tou Adrianou), est un monumental portail inspiré des arcs de triomphe romains.",
    rangement: ["C.1.1.3", "A.1.2", "C.3.1", "T.1.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Le jour des 13 heures",
    type: ["Video"],
    note: "Athènes, 1ᵉʳ octobre 2025. La Grèce vit au ralenti : syndicats et travailleurs observent une grève générale contre la réforme autorisant des journées de travail de treize heures.\nCe film suit une journée de rassemblements et de voix qui résonnent place Syntagma.",
    link: "https://sous-les-titres.fr/films/le%20jour%20des%2013%20heures/le%20jour%20des%2013%20heures",
    rangement: ["A.5.2.2", "A.5.2.1", "P.3", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Graffiti anarchiste",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0642.webp", alt: "Graffiti anarchiste" }],
    note: "Graffiti anarchiste",
    coment: "Il est fréquent de retrouver ce graffiti sur le mobilier urbain ou à même les murs, dans bien des cas; lorsqu'ils sont effacés, ils sont reproduits les jours suivants.",
    rangement: ["A.5.2.1", "A.4.2", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Graffiti récurrent",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0709.webp", alt: "Graffiti anarchiste" }],
    note: "Il est fréquent de retrouver ce graffiti un peu partout à Athènes, à voir s'il a une signification particulière",
    coment: "L'inscription \"Man Spreading\" n'est pas présente sur les autres graffitis rencontrés.",
    rangement: ["A.4.2", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
      {
    id: 1,
    annee: 2025,
    titre: "Nerantzies",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0628.webp", alt: "" }],
    note: "This is a species of orange tree that is used in urban settings and is for decorative purposes only\nS'intègre dans le plan de plantation lancée par le maire d'athènes pour lutter contre les ilots de chaleur",
    rangement: ["A.7.2", "P.4.1", "P.1.5", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
    {
    id: 1,
    annee: 2024,
    titre: "NOUS N'AVONS PAS PEUR DES RUINES",
    type: ["Video"],
    note: "Que se passe-t-il en Grèce ? Voici un film qui offre un autre regard que celui proposé par les médias dominants. Un regard depuis l'intérieur du mouvement social à Athènes, en Crète et jusqu'à Paros. Un voyage en musique au sein de collectifs grecs en lutte pour une société plus juste et plus solidaire.",
    link: "https://www.youtube.com/watch?v=W1IcUvKz-dE",
    rangement: ["A.5.2.2", "A.5.2.1", "P.3", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Exárcheia" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Stationnements Vélos",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0737.webp", alt: "" }],
    note: "Emplacements permettant le stationnement de vélos",
    coment: "Cette installation peut paraître étonnante, étant donné la faible utilisation du vélo à Athènes.",
    rangement: ["A.2.1", "A.3.2", "C.3.4", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
    {
    id: 1,
    annee: 2025,
    titre: "Bouche à incendie",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0717.webp", alt: "" }],
    note: "",
    rangement: ["A.2.1", "C.3.4", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },

   {
    id: 1,
    annee: 2025,
    titre: "Dromeas (the runner) by Kostas",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0739.webp", alt: "" }],
    note: "Photo of Dromeas (the runner) by Kostas Varotsos from Evangelismos.",
    rangement: ["A.4.1.1", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Kolonaki" }
  },
  {
    id: 2,
    annee: 2025,
    titre: "Yellow Taxis",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0614.webp", alt: "Yellow Taxi at Syntagma" }],
    note: "Taxi jaunes",
    rangement: ["A.3.1", "T.4"],
    localisation: { position: "Athens" }
  },
    {
    id: 2,
    annee: 2025,
    titre: "Scooters et motos",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0740.webp", alt: "" }],
    note: "Types de véhicules fréquemment utilisés par les Grecs",
    rangement: ["A.3.1", "T.4"],
    localisation: { position: "Athens" }
  },
    {
    id: 2,
    annee: 2025,
    titre: "Trottinettes électriques",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0730.webp", alt: "Trottinettes électriques" }],
    note: "Trottinettes électriques",
    rangement: ["A.3.2", "T.4"],
    localisation: { position: "Athens" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Fin de l’ère des taxophones: à Athènes, les cabines téléphoniques abandonnées sont massivement supprimées",
    type: ["Article"],
    link: "https://fr.rua.gr/2025/08/19/fin-de-lere-des-taxophones-a-athenes-les-cabines-telephoniques-abandonnees-sont-massivement-supprimees/",
    rangement: ["A.2.1","P.4.2", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
  {
    id: 3,
    annee: 2025,
    titre: "Carte collaborative des arbres à Athènes",
    type: ["Map"],
    link: "https://urbanivore.fr/contribute",
    rangement: ["A.7.3", "T.4"],
    localisation: { position: "Athens" }
  },
  {
    id: 1,
    annee: 2025,
    titre: "Cabine téléphonique abandonnée",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0639.webp", alt: "" }],
    note: "Ancinnes cabines téléphoniques, peu à peu démentelées.",
    rangement: ["A.2.1", "C.3.4", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina" }
  },
   {
    id: 3,
    annee: 2025,
    titre: "Mailboxe",
    type: ["Picture"],
    images: [{ url: "data/images/DSCF0637.webp", alt: "Mailboxe" }],
    note: "The mailboxes of Athens ...",
   rangement: ["A.2.1", "C.3.4", "T.4"],
    localisation: { position: "Athens" }
  },
  {
    id: 3,
    annee: 2022,
    titre: "A Exarchia, quartier contestataire d’Athènes, un métro de la discorde",
    type: ["Article"],
    link: "https://www.lemonde.fr/economie/article/2022/10/04/grece-a-exarchia-le-metro-de-la-discorde_6144332_3234.html",
   rangement: ["A.3.3.3", "P.4.2", "P.3", "P.1.3", "T.4"],
    localisation: { position: "Athens", municipalite: "Athina", quartier: "Exárcheia" }
  },
  {
    id: 3,
    annee: 2016,
    titre: "Plans d'Athènes pour une ville plus verte et plus fraîche",
    type: ["Article"],
    link: "https://www.c40.org/fr/case-studies/athens-plans-for-a-greener-and-cooler-city/",
   rangement: ["A.7.3", "P.4.1", "P.1.5", "T.4"],
    localisation: { position: "Athens" }
  },
];

/* --------- extraction de tags (compatible codes ou anciennes chaînes) --------- */
function getArticleTags(article) {
  if (!article || !Array.isArray(article.rangement) || article.rangement.length === 0) return [];
  const set = new Set();
  article.rangement.forEach(item => {
    if (isCode(item)) {
      const chain = codeToLabelChain(item);
      chain.forEach(c => set.add(String(c).toLowerCase()));
    } else {
      // ancienne logique: "Mobilier urbain, Fonctionnel"
      const chain = String(item).split(',').map(s=>s.trim()).filter(Boolean);
      chain.forEach(c => set.add(String(c).toLowerCase()));
    }
  });
  return Array.from(set);
}

/* ---------- filtrage / counts / rendu ---------- */
let activeTags = ["All"];
let activeFormats = ["All"];
let searchQuery = "";
let locPosition = "";
let locMunicipalite = "";
let locQuartier = "";
let currentLayerPath = []; // maintenant tableau de codes (ex ["1"] ou ["1","13"])

function getBaseForTagCounts() {
  let filtered = [...articles];
  if (searchQuery && searchQuery.trim() !== "") {
    const q = searchQuery.toLowerCase();
    filtered = filtered.filter(a => (a.titre + " " + (a.note||"") + " " + getArticleTags(a).join(" ")).toLowerCase().includes(q));
  }
  if (!activeFormats.includes("All") && activeFormats.length > 0) {
    filtered = filtered.filter(a => a.type && a.type.some(t => activeFormats.includes(t)));
  } else if (!activeFormats.includes("All") && activeFormats.length === 0) {
    filtered = [];
  }
  if (locPosition) filtered = filtered.filter(a => a.localisation?.position === locPosition);
  if (locMunicipalite) filtered = filtered.filter(a => a.localisation?.municipalite === locMunicipalite);
  if (locQuartier) filtered = filtered.filter(a => a.localisation?.quartier === locQuartier);
  return filtered;
}

function countArticlesForLeaves(leaves) {
  if (!leaves || leaves.length === 0) return 0;
  const base = getBaseForTagCounts();
  return base.filter(a => {
    const at = getArticleTags(a);
    return at && at.some(t => leaves.includes(String(t).toLowerCase()));
  }).length;
}

function applyFilters() {
  renderQuickFilters();
  renderFormatFilters();
  let result = [...articles];
  if (searchQuery.trim() !== "") {
    result = result.filter(a => (a.titre + " " + (a.note||"") + " " + getArticleTags(a).join(" ")).toLowerCase().includes(searchQuery));
  }
  if (!activeTags.includes("All") && activeTags.length > 0) {
    result = result.filter(a => {
      const atags = getArticleTags(a);
      return atags && atags.some(tag => activeTags.includes(tag));
    });
  } else if (!activeTags.includes("All") && activeTags.length === 0) {
    result = []; // aucun tag sélectionné → rien n'affiche
  }
  if (!activeFormats.includes("All") && activeFormats.length > 0) {
    result = result.filter(a => a.type && a.type.some(type => activeFormats.includes(type)));
  } else if (!activeFormats.includes("All") && activeFormats.length === 0) {
    result = [];
  }
  if (locPosition) result = result.filter(a => a.localisation?.position === locPosition);
  if (locMunicipalite) result = result.filter(a => a.localisation?.municipalite === locMunicipalite);
  if (locQuartier) result = result.filter(a => a.localisation?.quartier === locQuartier);
  renderArticles(result);
}

/* format filters */
function getAllFormats(articles) {
  const set = new Set();
  articles.forEach(a => a.type.forEach(f => set.add(f)));
  return [...set];
}
function getFilteredForCounts() {
  let filtered = [...articles];
  if (searchQuery && searchQuery.trim() !== "") {
    const q = searchQuery.toLowerCase();
    filtered = filtered.filter(a => (a.titre + " " + (a.note||"") + " " + getArticleTags(a).join(" ")).toLowerCase().includes(q));
  }
  if (!activeTags.includes("All") && activeTags.length > 0) {
    filtered = filtered.filter(a => {
      const at = getArticleTags(a);
      return at && at.some(tag => activeTags.includes(tag));
    });
  } else if (!activeTags.includes("All") && activeTags.length === 0) {
    filtered = [];
  }
  if (locPosition) filtered = filtered.filter(a => a.localisation?.position === locPosition);
  if (locMunicipalite) filtered = filtered.filter(a => a.localisation?.municipalite === locMunicipalite);
  if (locQuartier) filtered = filtered.filter(a => a.localisation?.quartier === locQuartier);
  return filtered;
}
function filterFormat(format) {
  const buttons = document.querySelectorAll("#formatFilters button");
  if (format === "All") {
    activeFormats = ["All"];
  } else {
    activeFormats = activeFormats.filter(f => f !== "All");
    if (activeFormats.includes(format)) activeFormats = activeFormats.filter(f => f !== format);
    else activeFormats.push(format);
  }
  buttons.forEach(b => { const fmt = b.dataset.format; b.classList.toggle("active", activeFormats.includes(fmt)); });
  applyFilters();
}
function renderFormatFilters() {
  const container = document.getElementById("formatFilters");
  const formats = ["All", ...getAllFormats(articles)];
  const filteredForCounts = getFilteredForCounts();
  const counts = {};
  counts["All"] = filteredForCounts.length;
  formats.slice(1).forEach(f => counts[f] = filteredForCounts.filter(a => a.type && a.type.includes(f)).length);
  container.innerHTML = formats.map(f => {
    const n = counts[f] || 0;
    return `<button data-format="${f}" onclick="filterFormat('${f}')">${f} (${n})</button>`;
  }).join("");
  container.querySelectorAll("button").forEach(b => {
    const fmt = b.dataset.format; b.classList.toggle("active", activeFormats.includes(fmt));
  });
}
function renderArticles(data = articles) {
  const list = document.getElementById("list");
  list.innerHTML = "";
  data.forEach(article => {
    let imagesHTML = "";
    if (article.images && article.images.length) {
      imagesHTML = article.images.map(img => `
        <figure>
          <img class="thumb" src="${img.url}" alt="${img.alt}">
          <figcaption>${img.alt}</figcaption>
        </figure>
      `).join("");
    }

    /* ---------- Tags : grouper par axe (une seule ligne par axe, pas de doublons) ---------- */
    // groupedTags: { 'A': Set([...]), 'T': Set([...]), 'C': Set([...]), 'U': Set([...]) }
    const groupedTags = {};

    (article.rangement || []).forEach(codeOrLabel => {
      // 1) obtenir chaines labels (ex: ["Patrimoine bâti","Culte","Orthodoxe"])
      let labels = [];
      if (isCode(codeOrLabel)) labels = codeToLabelChain(codeOrLabel);
      else labels = String(codeOrLabel).split(',').map(s=>s.trim()).filter(Boolean);

      // 2) inférer la lettre d'axe
      let axisLetter = "";
      // si c'est un code pointé commençant par lettre -> première lettre
      if (isCode(codeOrLabel)) {
        const s = String(codeOrLabel);
        if (/^[A-Z]/.test(s)) axisLetter = s[0];
      } else {
        // si c'est une étiquette texte: cherche un code connu
        const found = findCodeByLabel(codeOrLabel);
        if (found && /^[A-Z]/.test(found)) axisLetter = found[0];
        else {
          // fallback : essayer chaque label du chain pour trouver un code
          for (let i=0;i<labels.length;i++){
            const f = findCodeByLabel(labels[i]);
            if (f && /^[A-Z]/.test(f)) { axisLetter = f[0]; break; }
          }
        }
      }
      if (!axisLetter) axisLetter = "U"; // U = unknown

      // 3) ajouter chaque label final (feuille) dans le set de l'axe
      if (!groupedTags[axisLetter]) groupedTags[axisLetter] = new Set();
      labels.forEach(l => {
        if (l) groupedTags[axisLetter].add(l);
      });
    });

    // construire HTML des tags (une ligne par axe, labels uniques, chaque label cliquable)
    const axisOrder = Object.keys(groupedTags).sort(); // tri simple (A,C,P,T,U...)
    const tagsHtml = axisOrder.map(axisLetter => {
      const set = groupedTags[axisLetter];
      if (!set || set.size === 0) return "";
      const axisDisplay = (axisLetter && axisLetter !== "U") ? `(${axisLetter}) :` : "";
      const axisHtml = axisDisplay ? `<span class="axis">${axisDisplay}</span>` : `<span class="axis"></span>`;
      const links = Array.from(set).map(lbl => {
        return `<a href="#" class="tag-link" onclick="filterTag('${escapeForOnClick(lbl)}'); return false;">${lbl}</a>`;
      }).join(`<span class="sep"> • </span>`);
      return `<p class="tag-line" title="${Array.from(set).join(' -> ')}">${axisHtml}<span class="tag-hierarchy">${links}</span></p>`;
    }).join("");

    const html = `
      <details class="item">
        <summary>
          <span>+ ${article.annee} — ${article.titre}</span>
          <span style="font-size:12px;color:var(--muted)">${article.type.join(", ")}</span>
        </summary>

        <div class="details-body">
          ${imagesHTML}
          <div class="info">
            <div>
              ${ article.note ? `<p style="white-space: pre-wrap"><strong>Note:</strong><br>${article.note}</p>` : "" }
              ${ article.link ? `<p><strong>Link:</strong> <a href="${article.link}" target="_blank">${article.link}</a></p>` : "" }

              ${ article.coment ? `<p class="comment"><strong>Coment:</strong> ${article.coment}</p>` : "" }

              ${ article.sources?.length ? `<p><strong>Sources :</strong></p>
                 <ul>${article.sources.map(src => src.url ? `<li><a href="${src.url}" target="_blank">${src.title}</a></li>` : `<li>${src.title}</li>`).join("")}</ul>` : "" }

              <div class="meta-tags">
                <strong>Tags:</strong>
                ${tagsHtml}
              </div>
            </div>

            ${ article.localisation ? `
              <div class="meta-small">
                <strong>Localisation :</strong><br>
                ${[ article.localisation.position, article.localisation.municipalite, article.localisation.quartier ].filter(Boolean).join(", ")}
              </div>
            ` : "" }
          </div>
        </div>
      </details>
    `;
    list.insertAdjacentHTML("beforeend", html);
  });
}


/* ---------- Quick Filters (drilldown) ---------- */
function enterLayer(code) {
  // code attendu : string code (ex "1" ou "13")
  if (!codeMap[code]) return;
  currentLayerPath.push(code);
  const leaves = getLeavesUnderPath(currentLayerPath);
  if (leaves.length) activeTags = [...leaves];
  else activeTags = activeTags.filter(t => t !== "All");
  applyFilters();
  renderQuickFilters();
}
function goUpLayer() {
  currentLayerPath.pop();
  if (currentLayerPath.length === 0) activeTags = ["All"];
  else {
    activeTags = getLeavesUnderPath(currentLayerPath);
    if (activeTags.length === 0) activeTags = ["All"];
  }
  applyFilters();
  renderQuickFilters();
}
function resetLayer() {
  currentLayerPath = [];
  activeTags = ["All"];
  applyFilters();
  renderQuickFilters();
}
function toggleLeafTag(leaf) {
  const tag = String(leaf).toLowerCase();
  activeTags = activeTags.filter(t => t !== "All");
  if (activeTags.includes(tag)) activeTags = activeTags.filter(t => t !== tag);
  else activeTags.push(tag);
  applyFilters();
  renderQuickFilters();
}

/* build root codes array */
const rootCodes = childrenMap["ROOT"] ? childrenMap["ROOT"].slice() : [];
function renderQuickFilters() {
  const container = document.getElementById("quickFilters");
  if (!container) return;
  const baseForCounts = getBaseForTagCounts();
  const allCount = baseForCounts.length;

  // 1) barre d'axes (toujours visible)
  let html = `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px">`;
  Object.values(axes).forEach(ax => {
    const activeClass = (currentAxis === ax.key) ? "active" : "";
    html += `<button onclick="enterAxis('${ax.key}')" class="${activeClass}" data-axis="${ax.key}">${ax.label}</button>`;
  });
  html += `<button onclick="resetAxis()">Afficher tout</button>`; // Inutile si pas de mode OR...
  html += `</div>`;

  // 2) bouton All (compteur global)
  html += `<div style="width:100%;height:6px"></div>`;
  //html += `<button data-tag="All" onclick="resetLayer()">All (${allCount})</button>`;

  // 3) afficher racines utiles (NE PAS afficher les lettres d'axe seules)
  // si on est dans un chemin (currentLayerPath non vide) : afficher enfants du noeud courant
  if (currentLayerPath.length === 0) {
    // Si un axe est sélectionné, n'afficher que les racines de cet axe ;
    // sinon afficher toutes les racines SAUF les codes qui sont une lettre d'axe (A,T,...)
    const rootsToShow = currentAxis ? (axes[currentAxis].roots || []) : (childrenMap["ROOT"] ? childrenMap["ROOT"].slice() : []);
    rootsToShow.forEach(rootCode => {
      // sauter les codes top-level qui sont des lettres simples (A, T, C, P...)
      if (rootCode.length === 1) return;
      const leaves = getLeavesUnderPath([rootCode]);
      const n = countArticlesForLeaves(leaves);
      if (n === 0) return;
      html += `<button data-parent="${escapeForOnClick(rootCode)}" onclick="enterLayer('${escapeForOnClick(rootCode)}')">${labelForCode(rootCode)} (${n})</button>`;
    });
  } else {
    // chemin courant + bouton retour vers le parent
    const chainLabels = currentLayerPath.map(c=>labelForCode(c)).join(' -> ');
    html += `<button onclick="goUpLayer()" class="active">${chainLabels}</button>`;
    const nodeCode = currentLayerPath[currentLayerPath.length - 1];
    const children = childrenMap[nodeCode] || [];
    children.forEach(childCode => {
      const leaves = getLeavesUnderPath([...currentLayerPath, childCode]);
      const n = countArticlesForLeaves(leaves);
      if (n === 0) return;
      html += `<button data-child="${escapeForOnClick(childCode)}" onclick="enterLayer('${escapeForOnClick(childCode)}')">${labelForCode(childCode)} (${n})</button>`;
    });
  }

  container.innerHTML = html;

  // marque visuellement la racine active si on est au premier niveau
  if (currentLayerPath.length === 1) {
    container.querySelectorAll("button[data-parent]").forEach(b => {
      b.classList.toggle("active", b.getAttribute("data-parent") === currentLayerPath[0]);
    });
  }

  // marque les boutons d'axe
  container.querySelectorAll("button[data-axis]").forEach(b => {
    const ax = b.getAttribute("data-axis");
    b.classList.toggle("active", currentAxis === ax);
  });
}



/* --------- filterTag: gère labels et codes ---------- */
function findCodeByLabel(label) {
  if (!label) return null;
  const lower = String(label).toLowerCase();
  // 1) quick map
  if (labelToCodeMap[lower]) return labelToCodeMap[lower];
  // 2) exact match among codeMap values
  for (const [c,l] of Object.entries(codeMap)) {
    if (String(l).toLowerCase() === lower) return c;
  }
  return null;
}

function filterTag(tag) {
  const lower = String(tag).toLowerCase();

  // 1) si tag correspond exactement à un label connu -> bascule code / entrée dans layer
  const code = findCodeByLabel(tag);
  if (code) {
    // si code est une racine ou un parent: entrer dans sa couche
    enterLayer(code);
    return;
  }

  // 2) si tag apparaît dans les feuilles connues -> toggle
  const allLeaves = getLeavesUnderPath([]);
  if (allLeaves.includes(lower)) {
    toggleLeafTag(lower);
    return;
  }

  // 3) fallback : toggle simple (conserver ancien comportement)
  toggleLeafTag(lower);
}

/* ---------- location helpers ---------- */
function getAllLocations(articles) {
  const positions = new Set();
  const municipalites = new Set();
  const quartiers = new Set();
  articles.forEach(a => {
    if (a.localisation) {
      if (a.localisation.position) positions.add(a.localisation.position);
      if (a.localisation.municipalite) municipalites.add(a.localisation.municipalite);
      if (a.localisation.quartier) quartiers.add(a.localisation.quartier);
    }
  });
  return { positions: [...positions], municipalites: [...municipalites], quartiers: [...quartiers] };
}
function renderLocationFilters() {
  const posSel = document.getElementById("positionFilter");
  const munSel = document.getElementById("municipaliteFilter");
  const quaSel = document.getElementById("quartierFilter");
  posSel.innerHTML = `<option value="">Position</option>`;
  munSel.innerHTML = `<option value="">Municipality</option>`;
  quaSel.innerHTML = `<option value="">Neighborhood</option>`;
  const allPositions = new Set();
  articles.forEach(a => { if (a.localisation?.position) allPositions.add(a.localisation.position); });
  allPositions.forEach(p => posSel.insertAdjacentHTML("beforeend", `<option value="${p}">${p}</option>`));
  let filteredByPosition = articles;
  if (locPosition) filteredByPosition = filteredByPosition.filter(a => a.localisation?.position === locPosition);
  const municipalites = new Set();
  filteredByPosition.forEach(a => { if (a.localisation?.municipalite) municipalites.add(a.localisation.municipalite); });
  municipalites.forEach(m => munSel.insertAdjacentHTML("beforeend", `<option value="${m}">${m}</option>`));
  let filteredByPosAndMun = filteredByPosition;
  if (locMunicipalite) filteredByPosAndMun = filteredByPosAndMun.filter(a => a.localisation?.municipalite === locMunicipalite);
  const quartiers = new Set();
  filteredByPosAndMun.forEach(a => { if (a.localisation?.quartier) quartiers.add(a.localisation.quartier); });
  quartiers.forEach(q => quaSel.insertAdjacentHTML("beforeend", `<option value="${q}">${q}</option>`));
  if (!allPositions.has(locPosition)) locPosition = "";
  if (!municipalites.has(locMunicipalite)) locMunicipalite = "";
  if (!quartiers.has(locQuartier)) locQuartier = "";
  posSel.value = locPosition;
  munSel.value = locMunicipalite;
  quaSel.value = locQuartier;
}
function filterLocation() {
  locPosition = document.getElementById("positionFilter").value;
  locMunicipalite = document.getElementById("municipaliteFilter").value;
  locQuartier = document.getElementById("quartierFilter").value;
  renderLocationFilters();
  applyFilters();
}
function filterList() {
  const v = document.getElementById('searchbox').value || "";
  searchQuery = v.trim().toLowerCase();
  applyFilters();
}
function resetFilters() {
    currentAxis = null;

  locPosition = ""; locMunicipalite = ""; locQuartier = "";
  ['positionFilter','municipaliteFilter','quartierFilter'].forEach(id=>{ const el=document.getElementById(id); if(el) el.value=""; });
  const sb = document.getElementById('searchbox'); if (sb) sb.value = "";
  searchQuery = "";
  activeFormats = ["All"];
  document.querySelectorAll('#list details[open]').forEach(d => d.removeAttribute('open'));
  resetLayer();
  renderFormatFilters();
  renderLocationFilters();
  applyFilters();
}

/* sort */
function sortBy(mode){
  const list = document.getElementById('list');
  const items = Array.from(list.querySelectorAll('.item'));
  if(mode === 'date'){
    items.sort((a,b)=>{
      const da = (a.innerText.match(/\b(19|20)\d{2}\b/)||['9999'])[0];
      const db = (b.innerText.match(/\b(19|20)\d{2}\b/)||['9999'])[0];
      return parseInt(db) - parseInt(da);
    });
  }
  items.forEach(i=>list.appendChild(i));
}

/* initial render */
renderQuickFilters();
renderFormatFilters();
renderLocationFilters();
renderArticles();

  </script>
</body>
</html>


